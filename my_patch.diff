diff --git a/examples/feature_demo/dynamic_env_map.py b/examples/feature_demo/dynamic_env_map.py
index 4de832f..b72ac26 100644
--- a/examples/feature_demo/dynamic_env_map.py
+++ b/examples/feature_demo/dynamic_env_map.py
@@ -36,7 +36,7 @@ cube_size = env_img.shape[1]
 env_img.shape = 6, cube_size, cube_size, env_img.shape[-1]
 
 env_static = gfx.Texture(
-    env_img, dim=2, size=(cube_size, cube_size, 6), generate_mipmaps=True
+    env_img, dim=2, size=(cube_size, cube_size, 6), generate_mipmaps=True, colorspace="tex-srgb"
 )
 
 # Create the dynamic env map
diff --git a/examples/feature_demo/earth.py b/examples/feature_demo/earth.py
index 0b5b176..0713938 100644
--- a/examples/feature_demo/earth.py
+++ b/examples/feature_demo/earth.py
@@ -46,11 +46,11 @@ scene = gfx.Scene()
 earth_geometry = gfx.sphere_geometry(63.71, 100, 50)
 
 
-def load_texture(path, flip=False):
+def load_texture(path, flip=False, colorspace="tex-srgb"):
     img = iio.imread(path)
     if flip:
         img = np.ascontiguousarray(np.flipud(img))
-    tex = gfx.Texture(img, dim=2)
+    tex = gfx.Texture(img, dim=2, colorspace=colorspace)
     return tex
 
 
@@ -75,7 +75,7 @@ earth_material.emissive_intensity = 3.0
 # earth_material.light_map_intensity = 3.0
 
 earth_material.normal_map = load_texture(
-    model_dir / "planets" / "earth_normal_2048.jpg", flip=True
+    model_dir / "planets" / "earth_normal_2048.jpg", flip=True, colorspace="physical"
 )
 earth_material.normal_scale = 0.85, -0.85
 
diff --git a/examples/feature_demo/env_maps.py b/examples/feature_demo/env_maps.py
index e9e9a36..7bde066 100644
--- a/examples/feature_demo/env_maps.py
+++ b/examples/feature_demo/env_maps.py
@@ -47,7 +47,7 @@ env_img.shape = 6, cube_size, cube_size, env_img.shape[-1]
 
 # Create environment map
 env_tex = gfx.Texture(
-    env_img, dim=2, size=(cube_size, cube_size, 6), generate_mipmaps=True
+    env_img, dim=2, size=(cube_size, cube_size, 6), generate_mipmaps=True, colorspace="tex-srgb"
 )
 
 teapot = trimesh.load(TEAPOT)
diff --git a/examples/feature_demo/gltf_viewer.py b/examples/feature_demo/gltf_viewer.py
index 1c046c0..0dc8b0f 100644
--- a/examples/feature_demo/gltf_viewer.py
+++ b/examples/feature_demo/gltf_viewer.py
@@ -81,14 +81,14 @@ env_img.shape = 6, cube_size, cube_size, env_img.shape[-1]
 
 # Create environment map
 env_tex = gfx.Texture(
-    env_img, dim=2, size=(cube_size, cube_size, 6), generate_mipmaps=True
+    env_img, dim=2, size=(cube_size, cube_size, 6), generate_mipmaps=True, colorspace=gfx.ColorSpace.srgb
 )
 
 background = gfx.Background(None, gfx.BackgroundSkyboxMaterial(map=env_tex))
 background.visible = False
 scene.add(background)
 
-scene.add(gfx.Background.from_color((0.1, 0.1, 0.1, 1)))
+scene.add(gfx.Background.from_color(gfx.Color(0.1, 0.1, 0.1, 1).to_physical()))
 
 
 def add_env_map(obj, env_map):
diff --git a/examples/feature_demo/lightmap.py b/examples/feature_demo/lightmap.py
index 8b0c330..5727672 100644
--- a/examples/feature_demo/lightmap.py
+++ b/examples/feature_demo/lightmap.py
@@ -42,7 +42,7 @@ renderer = gfx.renderers.WgpuRenderer(canvas)
 meshes = gfx.load_gltf_mesh(model_dir / "lightmap" / "scene.gltf", materials=False)
 
 light_map = iio.imread(model_dir / "lightmap" / "lightmap-ao-shadow.png")
-light_map_tex = gfx.Texture(light_map, dim=2)
+light_map_tex = gfx.Texture(light_map, dim=2, colorspace="tex-srgb")
 
 # Create camera and controller
 camera = gfx.PerspectiveCamera(45, 1)
diff --git a/pygfx/__init__.py b/pygfx/__init__.py
index f86f62e..6735292 100644
--- a/pygfx/__init__.py
+++ b/pygfx/__init__.py
@@ -17,6 +17,14 @@ from .animation import *
 from .renderers import *
 
 from .utils.color import Color
+
+from .utils.show import show, Display
+from .utils.viewport import Viewport
+from .utils.text import font_manager
+from .utils import cm, enums, logger
+from .utils.enums import *
+from .utils.color_management import ColorManagement
+
 from .utils.load import load_mesh, load_meshes, load_scene
 from .utils.load_gltf import (
     load_gltf,
@@ -25,11 +33,6 @@ from .utils.load_gltf import (
     load_gltf_mesh_async,
     print_scene_graph,
 )
-from .utils.show import show, Display
-from .utils.viewport import Viewport
-from .utils.text import font_manager
-from .utils import cm, enums, logger
-from .utils.enums import *
 
 # Temp fix for pyinstaller to pick up pylinalg
 import pylinalg
diff --git a/pygfx/animation/keyframe_track.py b/pygfx/animation/keyframe_track.py
index 38f4843..db32803 100644
--- a/pygfx/animation/keyframe_track.py
+++ b/pygfx/animation/keyframe_track.py
@@ -23,7 +23,7 @@ class KeyframeTrack:
             # remove adjacent keyframes scheduled at the same times
             if time != prev_time:
                 if np.any(value != prev_value):
-                    if prev_time is not None:
+                    if prev_time != optimized_times[-1] if optimized_times else None:
                         optimized_times.append(prev_time)
                         optimized_values.append(prev_value)
                     optimized_times.append(time)
diff --git a/pygfx/renderers/wgpu/engine/update.py b/pygfx/renderers/wgpu/engine/update.py
index b15dbf1..d9b2534 100644
--- a/pygfx/renderers/wgpu/engine/update.py
+++ b/pygfx/renderers/wgpu/engine/update.py
@@ -10,6 +10,8 @@ from ....utils import logger
 from .utils import to_texture_format, GfxSampler, GfxTextureView
 from .mipmapsutil import get_mip_level_count, generate_texture_mipmaps
 from .shared import get_shared
+from ....utils.enums import ColorSpace
+from ....utils.color_management import ColorManagement
 
 
 # Alternative texture formats that we support by padding channels as needed.
@@ -141,15 +143,46 @@ def ensure_wgpu_object(resource):
         resource._gfx_mark_for_sync()
 
     elif isinstance(resource, Texture):
-        fmt = to_texture_format(resource.format)
-        if fmt in ALTTEXFORMAT:
-            fmt = ALTTEXFORMAT[fmt][0]
-        if resource.colorspace == "tex-srgb" and not fmt.endswith("-srgb"):
-            fmt += "-srgb"
-        elif resource.colorspace == "srgb" and fmt.endswith("-srgb"):
-            logger.warning(
-                "Using texture.format 'xx-srgb' AND texture.colorspace 'srgb'."
-            )
+        if resource.format in wgpu.TextureFormat:
+            # if user specified a valid wgpu format, use it as-is
+            # and we don't take care of colorspace, just use the data as-is
+            # User should know what they are doing, and ensure their data is correct.
+            # todo: remove this option (use wgpu.TextureFormat) in the future?
+            fmt = resource.format
+        else:
+
+            fmt = to_texture_format(resource.format)
+            if fmt in ALTTEXFORMAT:
+                fmt = ALTTEXFORMAT[fmt][0]
+
+            color_space = resource.colorspace
+            if color_space == ColorSpace.no_colorspace:
+                pass
+            elif color_space == ColorManagement.working_color_space:
+                # No conversion needed, we can use the texture as-is
+                pass
+            elif color_space == ColorSpace.srgb:
+                fmt_srgb = fmt + "-srgb"
+                if fmt_srgb not in wgpu.TextureFormat:
+                    # In practice, floating-point textures are typically in the linear-sRGB space or marked as having no color space.
+                    # If a floating-point texture is marked with a color space of sRGB, we issue a warning.
+                    logger.warning(
+                        f"Texture {resource} has format {resource.format} with colorspace {color_space}, not supported."
+                    )
+                else:
+                    # auto srgb -> linear conversion
+                    fmt = fmt_srgb
+
+            elif color_space == ColorSpace.linear_srgb:
+                # ColorManagement.working_color_space is srgb
+                # should use linear -> srgb conversion, but in practice, such cases are extremely rare—most occurrences are due to the user mistakenly configuring the ColorSpace.  
+                # Therefore, we simply issue a warning here.  
+                # If, for some very special reason, a user truly needs to use a linear-sRGB texture while working in the sRGB color space,  
+                # it is the user’s responsibility to convert the texture to sRGB themselves.
+                logger.warning(
+                    f"Texture {resource} has format {resource.format} with colorspace {color_space}, not supported."
+                )
+
         if resource.data is not None:
             resource._wgpu_usage |= wgpu.TextureUsage.COPY_DST
         usage = resource._wgpu_usage
@@ -172,10 +205,7 @@ def ensure_wgpu_object(resource):
         if resource.is_default_view:
             resource._wgpu_object = wgpu_texture.create_view()
         else:
-            fmt = to_texture_format(resource.format)
-            fmt = ALTTEXFORMAT.get(fmt, [fmt])[0]
             resource._wgpu_object = wgpu_texture.create_view(
-                format=fmt,
                 dimension=resource.view_dim,
                 aspect=resource.aspect,
                 base_mip_level=resource.mip_range[0],
diff --git a/pygfx/renderers/wgpu/shaders/lineshader.py b/pygfx/renderers/wgpu/shaders/lineshader.py
index ed70f7b..3b4ca99 100644
--- a/pygfx/renderers/wgpu/shaders/lineshader.py
+++ b/pygfx/renderers/wgpu/shaders/lineshader.py
@@ -485,7 +485,7 @@ class ThinLineShader(LineShader):
                 let color = u_material.color;
             $$ endif
 
-            let physical_color = srgb2physical(color.rgb);
+            let physical_color = color.rgb;
             let opacity = color.a * u_material.opacity;
             let out_color = vec4<f32>(physical_color, opacity);
 
diff --git a/pygfx/renderers/wgpu/wgsl/background.wgsl b/pygfx/renderers/wgpu/wgsl/background.wgsl
index f80b562..cbdb2c9 100644
--- a/pygfx/renderers/wgpu/wgsl/background.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/background.wgsl
@@ -75,10 +75,11 @@ fn fs_main(varyings: Varyings) -> FragmentOutput {
             + u_material.color_top_left * (1.0 - f.x) * f.y
             + u_material.color_top_right * f.x * f.y
         );
+        final_color = vec4<f32>(final_color.rgb, final_color.a);
     $$ endif
 
     // Make physical color with combined alpha
-    let physical_color = srgb2physical(final_color.rgb);
+    let physical_color = final_color.rgb;
     let opacity = final_color.a * u_material.opacity;
     let out_color = vec4<f32>(physical_color, opacity);
 
diff --git a/pygfx/renderers/wgpu/wgsl/grid.wgsl b/pygfx/renderers/wgpu/wgsl/grid.wgsl
index b36329a..bcac3e9 100644
--- a/pygfx/renderers/wgpu/wgsl/grid.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/grid.wgsl
@@ -273,7 +273,7 @@ fn fs_main(varyings: Varyings) -> FragmentOutput {
     // ---------------------
 
     // Make physical color with combined alpha
-    let physical_color = srgb2physical(color.rgb);
+    let physical_color = color.rgb;
     let opacity = alpha * color.a * u_material.opacity;
     let out_color = vec4<f32>(physical_color, opacity);
 
diff --git a/pygfx/renderers/wgpu/wgsl/image.wgsl b/pygfx/renderers/wgpu/wgsl/image.wgsl
index ab2aee3..e59b2e5 100644
--- a/pygfx/renderers/wgpu/wgsl/image.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/image.wgsl
@@ -45,14 +45,8 @@ fn fs_main(varyings: Varyings) -> FragmentOutput {
     let value = sample_im(varyings.texcoord.xy, sizef);
     let color = sampled_value_to_color(value);
 
-    // Move to physical colorspace (linear photon count) so we can do math
-    $$ if colorspace == 'srgb' or colorspace.startswith('yuv')
-        let physical_color = srgb2physical(color.rgb);
-    $$ else
-        let physical_color = color.rgb;
-    $$ endif
     let opacity = color.a * u_material.opacity;
-    let out_color = vec4<f32>(physical_color, opacity);
+    let out_color = vec4<f32>(color.rgb, opacity);
 
     do_alpha_test(opacity);
 
diff --git a/pygfx/renderers/wgpu/wgsl/light_common.wgsl b/pygfx/renderers/wgpu/wgsl/light_common.wgsl
index 668a870..f966d9f 100644
--- a/pygfx/renderers/wgpu/wgsl/light_common.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/light_common.wgsl
@@ -38,7 +38,7 @@ struct GeometricContext {
 $$ if num_dir_lights > 0
 fn getDirectionalLightInfo( directional_light: DirectionalLight, geometry: GeometricContext ) -> IncidentLight {
     var light: IncidentLight;
-    light.color = srgb2physical(directional_light.color.rgb) * directional_light.intensity;
+    light.color = directional_light.color.rgb * directional_light.intensity;
     light.direction = -directional_light.direction.xyz;
     light.visible = true;
     return light;
@@ -51,7 +51,7 @@ fn getPointLightInfo( point_light: PointLight, geometry: GeometricContext ) -> I
     let i_vector = point_light.world_transform[3].xyz - geometry.position;
     light.direction = normalize(i_vector);
     let light_distance = length(i_vector);
-    light.color = srgb2physical(point_light.color.rgb) * point_light.intensity;
+    light.color = point_light.color.r * point_light.intensity;
     light.color *= getDistanceAttenuation( light_distance, point_light.distance, point_light.decay );
     light.visible = any(light.color != vec3<f32>(0.0));
     return light;
@@ -67,7 +67,7 @@ fn getSpotLightInfo( spot_light: SpotLight, geometry: GeometricContext ) -> Inci
     let spot_attenuation = getSpotAttenuation(spot_light.cone_cos, spot_light.penumbra_cos, angle_cos);
     if ( spot_attenuation > 0.0 ) {
         let light_distance = length( i_vector );
-        light.color = srgb2physical(spot_light.color.rgb) * spot_light.intensity;
+        light.color = spot_light.color.rgb * spot_light.intensity;
         light.color *= spot_attenuation;
         light.color *= getDistanceAttenuation( light_distance, spot_light.distance, spot_light.decay );
         light.visible = any(light.color != vec3<f32>(0.0));
diff --git a/pygfx/renderers/wgpu/wgsl/light_pbr.wgsl b/pygfx/renderers/wgpu/wgsl/light_pbr.wgsl
index 43dbefc..6facd56 100644
--- a/pygfx/renderers/wgpu/wgsl/light_pbr.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/light_pbr.wgsl
@@ -202,8 +202,8 @@ fn getMipLevel(maxMIPLevelScalar: f32, level: f32) -> f32 {
 
 fn getIBLIrradiance( normal: vec3<f32> ) -> vec3<f32> {
     let mip_level = getMipLevel(u_material.env_map_max_mip_level, 1.0);
-    let envMapColor_srgb = textureSampleLevel( t_env_map, s_env_map, vec3<f32>( -normal.x, normal.yz), mip_level );
-    return srgb2physical(envMapColor_srgb.rgb) * u_material.env_map_intensity * PI;
+    let envMapColor = textureSampleLevel( t_env_map, s_env_map, vec3<f32>( -normal.x, normal.yz), mip_level );
+    return envMapColor.rgb * u_material.env_map_intensity * PI;
 }
 
 fn getIBLRadiance(view_dir: vec3<f32>, normal: vec3<f32>, roughness: f32) -> vec3<f32> {
@@ -215,8 +215,8 @@ fn getIBLRadiance(view_dir: vec3<f32>, normal: vec3<f32>, roughness: f32) -> vec
         let mip_level = 1.0;
     $$ endif
     reflectVec = normalize(mix(reflectVec, normal, roughness*roughness));
-    let envMapColor_srgb = textureSampleLevel( t_env_map, s_env_map, vec3<f32>( -reflectVec.x, reflectVec.yz), mip_level );
-    return srgb2physical(envMapColor_srgb.rgb) * u_material.env_map_intensity;
+    let envMapColor = textureSampleLevel( t_env_map, s_env_map, vec3<f32>( -reflectVec.x, reflectVec.yz), mip_level );
+    return envMapColor.rgb * u_material.env_map_intensity;
 }
 
 
diff --git a/pygfx/renderers/wgpu/wgsl/light_pbr_fragment.wgsl b/pygfx/renderers/wgpu/wgsl/light_pbr_fragment.wgsl
index e63c050..4b85f83 100644
--- a/pygfx/renderers/wgpu/wgsl/light_pbr_fragment.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/light_pbr_fragment.wgsl
@@ -29,10 +29,10 @@ $$ if USE_IOR is defined
 
     $$ if USE_SPECULAR
         var specular_intensity = u_material.specular_intensity;
-        var specular_color = srgb2physical(u_material.specular_color.rgb);
-        
+        var specular_color = u_material.specular_color.rgb;
+
         $$ if use_specular_map is defined
-            specular_color *= srgb2physical(textureSample( t_specular_map, s_specular_map, specular_map_uv ).rgb);
+            specular_color *= textureSample( t_specular_map, s_specular_map, specular_map_uv ).rgb;
         $$ endif
 
         $$ if use_specular_intensity_map is defined
@@ -113,7 +113,7 @@ $$ endif
 
 $$ if USE_SHEEN is defined
 
-    material.sheen_color = srgb2physical(u_material.sheen_color.rgb) * u_material.sheen;
+    material.sheen_color = u_material.sheen_color.rgb * u_material.sheen;
 
     $$ if use_sheen_color_map is defined
         material.sheen_color *= textureSample( t_sheen_color_map, s_sheen_color_map, varyings.texcoord{{sheen_color_map_uv or ''}} ).rgb;
diff --git a/pygfx/renderers/wgpu/wgsl/light_phong_fragment.wgsl b/pygfx/renderers/wgpu/wgsl/light_phong_fragment.wgsl
index b229a40..6595a7c 100644
--- a/pygfx/renderers/wgpu/wgsl/light_phong_fragment.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/light_phong_fragment.wgsl
@@ -1,5 +1,5 @@
 var material: BlinnPhongMaterial;
 material.diffuse_color = physical_albeido;
-material.specular_color = srgb2physical(u_material.specular_color.rgb);
+material.specular_color = u_material.specular_color.rgb;
 material.specular_shininess = u_material.shininess;
 material.specular_strength = specular_strength;
\ No newline at end of file
diff --git a/pygfx/renderers/wgpu/wgsl/light_phong_simple.wgsl b/pygfx/renderers/wgpu/wgsl/light_phong_simple.wgsl
index e6531e6..cea09ce 100644
--- a/pygfx/renderers/wgpu/wgsl/light_phong_simple.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/light_phong_simple.wgsl
@@ -8,7 +8,7 @@
     view_dir: vec3<f32>,
     albeido: vec3<f32>,
 ) -> vec3<f32> {
-    let light_color = srgb2physical(vec3<f32>(1.0, 1.0, 1.0));
+    let light_color = vec3<f32>(1.0, 1.0, 1.0);
 
     // Light parameters
     let ambient_factor = 0.1;
@@ -35,7 +35,7 @@
     let specular_color = specular_factor * specular_term * light_color;
 
     // Emissive color is additive and unaffected by lights
-    let emissive_color = srgb2physical(u_material.emissive_color.rgb);
+    let emissive_color = u_material.emissive_color.rgb;
 
     // Put together
     return albeido * (ambient_color + diffuse_color) + specular_color + emissive_color;
diff --git a/pygfx/renderers/wgpu/wgsl/line.wgsl b/pygfx/renderers/wgpu/wgsl/line.wgsl
index 718d29f..54cbffd 100644
--- a/pygfx/renderers/wgpu/wgsl/line.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/line.wgsl
@@ -974,7 +974,7 @@ fn fs_main(varyings: Varyings, @builtin(front_facing) is_front: bool) -> Fragmen
     $$ else
         let color = u_material.color;
     $$ endif
-    var physical_color = srgb2physical(color.rgb);
+    var physical_color = color.rgb;
 
     $$ if false
         // Alternative debug options during dev.
diff --git a/pygfx/renderers/wgpu/wgsl/mesh.wgsl b/pygfx/renderers/wgpu/wgsl/mesh.wgsl
index 4ba35d5..fed8456 100644
--- a/pygfx/renderers/wgpu/wgsl/mesh.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/mesh.wgsl
@@ -383,7 +383,6 @@ fn fs_main(varyings: Varyings, @builtin(front_facing) is_front: bool) -> Fragmen
     $$ else
         // to support color modes
         var diffuse_color = u_material.color;
-        diffuse_color = vec4f(srgb2physical(diffuse_color.rgb), diffuse_color.a);
 
         $$ if color_mode != 'uniform'
             $$ if use_map
@@ -394,10 +393,6 @@ fn fs_main(varyings: Varyings, @builtin(front_facing) is_front: bool) -> Fragmen
                     var diffuse_map = textureSample(t_map, s_map, map_uv);
                 $$ endif
 
-                $$ if colorspace == 'srgb'
-                    diffuse_map = vec4f(srgb2physical(diffuse_map.rgb), diffuse_map.a);
-                $$ endif
-
                 $$ if color_mode == 'vertex_map' or color_mode == 'face_map'
                     diffuse_color = diffuse_map;
                 $$ else
@@ -516,7 +511,7 @@ fn fs_main(varyings: Varyings, @builtin(front_facing) is_front: bool) -> Fragmen
         var irradiance = getAmbientLightIrradiance( ambient_color );
         // Light map (pre-baked lighting)
         $$ if use_light_map is defined
-            let light_map_color = srgb2physical( textureSample( t_light_map, s_light_map, light_map_uv ).rgb );
+            let light_map_color = textureSample( t_light_map, s_light_map, light_map_uv ).rgb;
             irradiance += light_map_color * u_material.light_map_intensity;
         $$ endif
 
@@ -524,7 +519,6 @@ fn fs_main(varyings: Varyings, @builtin(front_facing) is_front: bool) -> Fragmen
         RE_IndirectDiffuse( irradiance, geometry, material, &reflected_light );
 
         // Indirect Specular Light
-        // IBL (srgb2physical and intensity is handled in the getter functions)
         $$ if USE_IBL is defined
 
             $$ if USE_ANISOTROPY is defined
@@ -546,7 +540,7 @@ fn fs_main(varyings: Varyings, @builtin(front_facing) is_front: bool) -> Fragmen
         // for basic material
         // Light map (pre-baked lighting)
         $$ if use_light_map is defined
-            let light_map_color = srgb2physical( textureSample( t_light_map, s_light_map, light_map_uv ).rgb );
+            let light_map_color = textureSample( t_light_map, s_light_map, light_map_uv ).rgb;
             reflected_light.indirect_diffuse += light_map_color * u_material.light_map_intensity * RECIPROCAL_PI;
         $$ else
             reflected_light.indirect_diffuse += vec3<f32>(1.0);
@@ -582,9 +576,9 @@ fn fs_main(varyings: Varyings, @builtin(front_facing) is_front: bool) -> Fragmen
     // Add emissive color
     // Now for phong、pbr and toon lighting
     $$ if lighting
-        var emissive_color = srgb2physical(u_material.emissive_color.rgb) * u_material.emissive_intensity;
+        var emissive_color = u_material.emissive_color.rgb * u_material.emissive_intensity;
         $$ if use_emissive_map is defined
-            emissive_color *= srgb2physical(textureSample(t_emissive_map, s_emissive_map, emissive_map_uv).rgb);
+            emissive_color *= textureSample(t_emissive_map, s_emissive_map, emissive_map_uv).rgb;
         $$ endif
         physical_color += emissive_color;
     $$ endif
@@ -610,8 +604,7 @@ fn fs_main(varyings: Varyings, @builtin(front_facing) is_front: bool) -> Fragmen
         $$ elif env_mapping_mode == "CUBE-REFRACTION"
             var reflectVec = refract( -view, normal, u_material.refraction_ratio );
         $$ endif
-        var env_color_srgb = textureSample( t_env_map, s_env_map, vec3<f32>( -reflectVec.x, reflectVec.yz) );
-        let env_color = srgb2physical(env_color_srgb.rgb); // TODO: maybe already in linear-space
+        let env_color = textureSample( t_env_map, s_env_map, vec3<f32>( -reflectVec.x, reflectVec.yz) );
         $$ if env_combine_mode == 'MULTIPLY'
             physical_color = mix(physical_color, physical_color * env_color.xyz, specular_strength * reflectivity);
         $$ elif env_combine_mode == 'MIX'
diff --git a/pygfx/renderers/wgpu/wgsl/mesh_normal_lines.wgsl b/pygfx/renderers/wgpu/wgsl/mesh_normal_lines.wgsl
index 48eb7db..6805d98 100644
--- a/pygfx/renderers/wgpu/wgsl/mesh_normal_lines.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/mesh_normal_lines.wgsl
@@ -57,17 +57,10 @@ fn fs_main(varyings: Varyings, @builtin(front_facing) is_front: bool) -> Fragmen
     {$ include 'pygfx.clipping_planes.wgsl' $}
 
     let color_value = u_material.color;
-    let albeido = color_value.rgb;
 
-    // Move to physical colorspace (linear photon count) so we can do math
-    $$ if colorspace == 'srgb'
-        let physical_albeido = srgb2physical(albeido);
-    $$ else
-        let physical_albeido = albeido;
-    $$ endif
     let opacity = color_value.a * u_material.opacity;
 
-    var physical_color = physical_albeido;
+    var physical_color = color_value.rgb;
     let out_color = vec4<f32>(physical_color, opacity);
 
     do_alpha_test(opacity);
diff --git a/pygfx/renderers/wgpu/wgsl/mesh_slice.wgsl b/pygfx/renderers/wgpu/wgsl/mesh_slice.wgsl
index 063b402..adbe6f1 100644
--- a/pygfx/renderers/wgpu/wgsl/mesh_slice.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/mesh_slice.wgsl
@@ -226,9 +226,8 @@ fn fs_main(varyings: Varyings) -> FragmentOutput {
     // No aa. This is something we need to decide on. See line renderer.
     let alpha = 1.0;
     // Set color
-    let physical_color = srgb2physical(albeido);
     let opacity = min(1.0, color_value.a) * alpha;
-    let out_color = vec4<f32>(physical_color, opacity);
+    let out_color = vec4<f32>(albeido, opacity);
 
     do_alpha_test(opacity);
 
diff --git a/pygfx/renderers/wgpu/wgsl/points.wgsl b/pygfx/renderers/wgpu/wgsl/points.wgsl
index 1dd5a0f..0a7315f 100644
--- a/pygfx/renderers/wgpu/wgsl/points.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/points.wgsl
@@ -364,9 +364,9 @@ fn fs_main(varyings: Varyings) -> FragmentOutput {
     $$ endif
 
     $$ if color_mode == 'debug'
-        let out_color = vec4<f32>(srgb2physical(the_color.rgb), the_color.a);
+        let out_color = the_color;
     $$ else
-        let out_color = vec4<f32>(srgb2physical(the_color.rgb), the_color.a * u_material.opacity);
+        let out_color = vec4<f32>(the_color.rgb, the_color.a * u_material.opacity);
     $$ endif
 
     // Always discard the empty space, but also allow custom alpha test
diff --git a/pygfx/renderers/wgpu/wgsl/text.wgsl b/pygfx/renderers/wgpu/wgsl/text.wgsl
index e0ae994..5758962 100644
--- a/pygfx/renderers/wgpu/wgsl/text.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/text.wgsl
@@ -288,7 +288,7 @@ fn fs_main(varyings: Varyings) -> FragmentOutput {
     // Get color for this fragment
     let base_srgb = u_material.color;
     let outline_srgb = u_material.outline_color;
-    let color = mix(srgb2physical(base_srgb.rgb), srgb2physical(outline_srgb.rgb), outline);
+    let color = mix(base_srgb.rgb, outline_srgb.rgb, outline);
     let color_alpha = mix(base_srgb.a, outline_srgb.a, outline);
 
     // Compose total opacity and the output color
diff --git a/pygfx/renderers/wgpu/wgsl/volume_ray.wgsl b/pygfx/renderers/wgpu/wgsl/volume_ray.wgsl
index 9e964dd..fb689d5 100644
--- a/pygfx/renderers/wgpu/wgsl/volume_ray.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/volume_ray.wgsl
@@ -198,14 +198,9 @@ $$ if mode == 'mip'
 
         // Colormapping
         let color = sampled_value_to_color(the_value);
-        // Move to physical colorspace (linear photon count) so we can do math
-        $$ if colorspace == 'srgb'
-            let physical_color = srgb2physical(color.rgb);
-        $$ else
-            let physical_color = color.rgb;
-        $$ endif
+
         let opacity = color.a * u_material.opacity;
-        let out_color = vec4<f32>(physical_color, opacity);
+        let out_color = vec4<f32>(color.rgb, opacity);
 
         // Produce result
         var out: RenderOutput;
@@ -267,14 +262,9 @@ $$ elif mode == 'minip'
 
         // Colormapping
         let color = sampled_value_to_color(the_value);
-        // Move to physical colorspace (linear photon count) so we can do math
-        $$ if colorspace == 'srgb'
-            let physical_color = srgb2physical(color.rgb);
-        $$ else
-            let physical_color = color.rgb;
-        $$ endif
+
         let opacity = color.a * u_material.opacity;
-        let out_color = vec4<f32>(physical_color, opacity);
+        let out_color = vec4<f32>(color.rgb, opacity);
 
         // Produce result
         var out: RenderOutput;
@@ -342,12 +332,6 @@ $$ elif mode == 'iso'
 
         // Colormapping
         let color = sampled_value_to_color(the_value);
-        // Move to physical colorspace (linear photon count) so we can do math
-        $$ if colorspace == 'srgb'
-            let physical_color = srgb2physical(color.rgb);
-        $$ else
-            let physical_color = color.rgb;
-        $$ endif
 
         // Compute the normal
         var normal : vec3<f32>;
@@ -371,7 +355,7 @@ $$ elif mode == 'iso'
         // Do the lighting
         let view_direction = normalize(step_coord);
         let is_front = dot(normal, view_direction) > 0.0;
-        let lighted_color = lighting_phong(is_front, normal, view_direction, physical_color);
+        let lighted_color = lighting_phong(is_front, normal, view_direction, color.rgb);
 
         let opacity = color.a * u_material.opacity;
         let out_color = vec4<f32>(lighted_color, opacity);
diff --git a/pygfx/renderers/wgpu/wgsl/volume_slice.wgsl b/pygfx/renderers/wgpu/wgsl/volume_slice.wgsl
index 4a2b751..263fcc4 100644
--- a/pygfx/renderers/wgpu/wgsl/volume_slice.wgsl
+++ b/pygfx/renderers/wgpu/wgsl/volume_slice.wgsl
@@ -179,14 +179,8 @@ fn fs_main(varyings: Varyings) -> FragmentOutput {
     let value = sample_vol(varyings.texcoord.xyz, sizef);
     let color = sampled_value_to_color(value);
 
-    // Move to physical colorspace (linear photon count) so we can do math
-    $$ if colorspace == 'srgb'
-        let physical_color = srgb2physical(color.rgb);
-    $$ else
-        let physical_color = color.rgb;
-    $$ endif
     let opacity = color.a * u_material.opacity;
-    let out_color = vec4<f32>(physical_color, opacity);
+    let out_color = vec4<f32>(color.rgb, opacity);
 
     do_alpha_test(out_color.a);
 
diff --git a/pygfx/resources/_texture.py b/pygfx/resources/_texture.py
index e3f6528..655f33d 100644
--- a/pygfx/resources/_texture.py
+++ b/pygfx/resources/_texture.py
@@ -12,6 +12,7 @@ from ._utils import (
     make_little_endian,
     logger,
 )
+from ..utils.enums import ColorSpace
 
 
 class Texture(Resource):
@@ -41,13 +42,7 @@ class Texture(Resource):
         Can also be wgpu's ``TextureFormat``. Optional: if None, it is
         automatically determined from the data.
     colorspace : str
-        If this data is used as color, it is interpreted to be in this
-        colorspace. Can be "srgb", "tex-srgb", "physical", "yuv420p", or "yuv444p". Default "srgb".
-    colorrange : str
-        For YUV textures, this is either "limited", or "full". For the limited range,
-        the luma plane is limited between 16-235, and the chroma planes (U and V) are
-        limited to 16-240. While it may seem suboptimal, many videos are stored in
-        the limited colorrange.
+        If this data is used as color, it is interpreted to be in this colorspace.
     generate_mipmaps : bool
         If True, automatically generates mipmaps when transferring data to the
         GPU. Default False.
@@ -84,8 +79,7 @@ class Texture(Resource):
         dim,
         size=None,
         format=None,
-        colorspace="srgb",
-        colorrange="limited",
+        colorspace=ColorSpace.no_colorspace,
         generate_mipmaps=False,
         chunk_size=None,
         force_contiguous=False,
@@ -107,16 +101,8 @@ class Texture(Resource):
         self._force_contiguous = bool(force_contiguous)
         assert dim in (1, 2, 3)
         self._store.dim = int(dim)
-        self._colorspace = (colorspace or "srgb").lower()
-        assert self._colorspace in (
-            "srgb",
-            "tex-srgb",
-            "physical",
-            "yuv420p",
-            "yuv444p",
-        )
-        self._colorrange = (colorrange or "limited").lower()
-        assert self._colorrange in ("limited", "full")
+        self._colorspace = colorspace
+
         self._generate_mipmaps = bool(generate_mipmaps)
 
         # Normalize size
@@ -274,43 +260,9 @@ class Texture(Resource):
     @property
     def colorspace(self):
         """If this data is used as color, it is interpreted to be in this colorspace.
-        Can be "srgb", "tex-srgb", "physical", "yuv420p", or "yuv444p". Default "srgb".
-
-        * "srgb": the data represents intensity, rgb, or rgba pixels in the sRGB space.
-          sRGB is a standard color space designed for consistent representation of colors
-          across devices like monitors. Most images store colors in this space.
-          The shader convers sRGB colors to physical in the shader before doing color computations.
-        * "tex-srgb": the underlying texture will be of an sRGB format. This means the data
-          is automatically converted to sRGB when it is sampled. This results in better glTF
-          compliance (because interpolation in the sampling happens in linear space).
-          Note that sampling *always* results in the sRGB values, also when not interpreted as color.
-          Only supported for rgb and rgba data.
-        * "physical": the colors are (already) in the physical / linear space, where lighting
-          calculations can be applied. Shader code that interprets the data as color will use it as-is.
-        * "yuv420p": A common video format. The data is represented as 3 planes (y, u, and v).
-          The y represents intensity, and is at full resolution. The u and v planes are a
-          quarter of the size. The planes must be stored in two layers of the texture,
-          with the u and v plane next to each-other in top half the second layer.
-        * "yuv444p": A lesser common video format. The data is represented as 3 planes
-          (y, u, and v) similar to yuv420p however the u and v planes are stored
-          at full resolution.
         """
         return self._colorspace
 
-    @property
-    def colorrange(self):
-        """For YUV textures, this is either "limited", or "full".
-
-        * "limited": The luma plane (Y) is limited to the range of 16-235 for 8 bits.
-                     The chroma planes (U and V) are limited to the range of 16-240 for 8 bits
-        * "full": The luma plane and chroma plane use the full range of the storage format.
-
-        See the following links from the FFMPEG documentation for more details:
-        https://trac.ffmpeg.org/wiki/colorspace
-        https://ffmpeg.org/doxygen/7.0/pixfmt_8h_source.html#l00609
-        """
-        return self._colorrange
-
     @property
     def generate_mipmaps(self):
         """Whether to automatically generate mipmaps when uploading to the GPU."""
diff --git a/pygfx/utils/color.py b/pygfx/utils/color.py
index 495f78e..0d46fcd 100644
--- a/pygfx/utils/color.py
+++ b/pygfx/utils/color.py
@@ -3,6 +3,8 @@
 import ctypes
 import colorsys
 import hsluv
+from .enums import ColorSpace
+from .color_management import ColorManagement
 
 F4 = ctypes.c_float * 4
 
@@ -76,19 +78,19 @@ class Color:
     # Internally, the color is a ctypes float array
     __slots__ = ["_val"]
 
-    def __init__(self, *args):
+    def __init__(self, *args, colorspace=None):
         if len(args) == 1:
             color = args[0]
             if isinstance(color, (int, float)):
-                self._set_from_tuple(args)
+                self._set_from_tuple(args, colorspace=colorspace)
             elif isinstance(color, str):
-                self._set_from_str(color)
+                self._set_from_str(color, colorspace=colorspace)
             else:
                 # Assume it's an iterable,
                 # may raise TypeError 'object is not iterable'
-                self._set_from_tuple(color)
+                self._set_from_tuple(color, colorspace=colorspace)
         else:
-            self._set_from_tuple(args)
+            self._set_from_tuple(args, colorspace=colorspace)
 
     def __repr__(self):
         # A precision of 4 decimals, i.e. 10001 possible values for each color.
@@ -145,7 +147,7 @@ class Color:
         a = max(0.0, min(1.0, float(a)))
         self._val = F4(float(r), float(g), float(b), a)
 
-    def _set_from_tuple(self, color):
+    def _set_from_tuple(self, color, colorspace=None):
         color = tuple(float(c) for c in color)
         if len(color) == 4:
             self._set_from_rgba(*color)
@@ -158,6 +160,9 @@ class Color:
         else:
             raise ValueError(f"Cannot parse color tuple with {len(color)} values")
 
+        if colorspace is not None:
+            ColorManagement.convert_to_working_space(self, colorspace)
+
     def _set_from_str(self, color):
         color = color.lower()
         if color.startswith("#"):
diff --git a/pygfx/utils/enums.py b/pygfx/utils/enums.py
index 93284b2..76f4e73 100644
--- a/pygfx/utils/enums.py
+++ b/pygfx/utils/enums.py
@@ -28,6 +28,7 @@ from typing import TypeAlias, Literal
 __all__ = [
     "BindMode",
     "ColorMode",
+    "ColorSpace",
     "CoordSpace",
     "EdgeMode",
     "ElementFormat",
@@ -183,6 +184,12 @@ class TextAnchor(Enum):
     bottom_right = "bottom-right"
 
 
+class ColorSpace(Enum):
+    no_colorspace = ""
+    linear_srgb = "linear_srgb"
+    srgb = "srgb"
+
+
 # TODO: I experimented with using a Literal[] here, an idea discussed in https://github.com/pygfx/wgpu-py/issues/720.
 # We should eventually use the same approach to all enums (either an Enum class, or Literal type aliases).
 
diff --git a/pygfx/utils/load_gltf.py b/pygfx/utils/load_gltf.py
index 1b1c663..de2f636 100644
--- a/pygfx/utils/load_gltf.py
+++ b/pygfx/utils/load_gltf.py
@@ -646,13 +646,14 @@ class _GLTF:
             pbr_metallic_roughness = material.pbrMetallicRoughness
             if pbr_metallic_roughness is not None:
                 if pbr_metallic_roughness.baseColorFactor is not None:
-                    gfx_material.color = gfx.Color.from_physical(
+                    gfx_material.color = gfx.Color(
                         *pbr_metallic_roughness.baseColorFactor
                     )
 
                 if pbr_metallic_roughness.baseColorTexture is not None:
                     gfx_material.map = self._load_gltf_texture_map(
-                        pbr_metallic_roughness.baseColorTexture
+                        pbr_metallic_roughness.baseColorTexture,
+                        colorspace=gfx.ColorSpace.srgb
                     )
 
                 if pbr_metallic_roughness.metallicRoughnessTexture is not None:
@@ -688,13 +689,14 @@ class _GLTF:
                 )
 
             if material.emissiveFactor is not None:
-                gfx_material.emissive = gfx.Color.from_physical(
+                gfx_material.emissive = gfx.Color(
                     *material.emissiveFactor
                 )
 
             if material.emissiveTexture is not None:
                 gfx_material.emissive_map = self._load_gltf_texture_map(
-                    material.emissiveTexture
+                    material.emissiveTexture,
+                    colorspace= gfx.ColorSpace.srgb
                 )
 
         # todo alphaMode
@@ -708,7 +710,7 @@ class _GLTF:
 
         return gfx_material
 
-    def _load_gltf_texture_map(self, texture_info):
+    def _load_gltf_texture_map(self, texture_info, colorspace=gfx.ColorSpace.no_colorspace):
         if isinstance(texture_info, dict):
             texture_index = texture_info["index"]
             uv_channel = texture_info.get("texCoord", 0)
@@ -718,7 +720,7 @@ class _GLTF:
             uv_channel = texture_info.texCoord or 0
             extensions = texture_info.extensions or {}
 
-        texture = self._load_gltf_texture(texture_index)
+        texture = self._load_gltf_texture(texture_index, colorspace=colorspace)
         if texture is None:
             return None
 
@@ -771,7 +773,7 @@ class _GLTF:
         return texture_map
 
     @lru_cache(maxsize=None)
-    def _load_gltf_texture(self, texture_index):
+    def _load_gltf_texture(self, texture_index, colorspace=gfx.ColorSpace.no_colorspace):
         texture_desc = self._gltf.model.textures[texture_index]
 
         extensions = texture_desc.extensions or {}
@@ -785,7 +787,7 @@ class _GLTF:
         if source is None:
             return None
         image = self._load_image(source)
-        texture = gfx.Texture(image, dim=2)
+        texture = gfx.Texture(image, dim=2, colorspace=colorspace)
         return texture
 
     @lru_cache(maxsize=None)
@@ -1194,13 +1196,14 @@ class GLTFMaterialsSpecularExtension(GLTFBaseMaterialsExtension):
             )
 
         specular_color = extension.get("specularColorFactor", [1.0, 1.0, 1.0])
-        material.specular = gfx.Color.from_physical(*specular_color)
+        material.specular = gfx.Color(*specular_color)
 
         specular_color_texture = extension.get("specularColorTexture", None)
 
         if specular_color_texture is not None:
             material.specular_map = self.parser._load_gltf_texture_map(
-                specular_color_texture
+                specular_color_texture,
+                colorspace=gfx.ColorSpace.srgb
             )
 
 
@@ -1333,12 +1336,13 @@ class GLTFMaterialsSheenExtension(GLTFBaseMaterialsExtension):
         sheen_color = extension.get("sheenColorFactor", None)
         if sheen_color is not None:
             material.sheen = 1.0
-            material.sheen_color = gfx.Color.from_physical(*sheen_color)
+            material.sheen_color = gfx.Color(*sheen_color)
 
         sheen_color_texture = extension.get("sheenColorTexture", None)
         if sheen_color_texture is not None:
             material.sheen_color_map = self.parser._load_gltf_texture_map(
-                sheen_color_texture
+                sheen_color_texture,
+                colorspace= gfx.ColorSpace.srgb
             )
 
         sheen_roughness_factor = extension.get("sheenRoughnessFactor", None)
@@ -1386,13 +1390,14 @@ class GLTFMaterialsUnlitExtension(GLTFBaseMaterialsExtension):
         pbr_metallic_roughness = material_def.pbrMetallicRoughness
         if pbr_metallic_roughness is not None:
             if pbr_metallic_roughness.baseColorFactor is not None:
-                material.color = gfx.Color.from_physical(
+                material.color = gfx.Color(
                     *pbr_metallic_roughness.baseColorFactor
                 )
 
             if pbr_metallic_roughness.baseColorTexture is not None:
                 material.map = self.parser._load_gltf_texture_map(
-                    pbr_metallic_roughness.baseColorTexture
+                    pbr_metallic_roughness.baseColorTexture,
+                    colorspace=gfx.ColorSpace.srgb
                 )
 
 
@@ -1430,7 +1435,7 @@ class GLTFLightsExtension(GLTFExtension):
             light_info = light_defs[light_index]
 
             color = light_info.get("color", [1, 1, 1])
-            light_color = gfx.Color.from_physical(*color)
+            light_color = gfx.Color(*color)
             light_range = light_info.get("range", 0)
             intensity = light_info.get("intensity", 1.0)
 
diff --git a/tests/animation/test_keyframe.py b/tests/animation/test_keyframe.py
index 54eac6e..96b3a66 100644
--- a/tests/animation/test_keyframe.py
+++ b/tests/animation/test_keyframe.py
@@ -36,3 +36,14 @@ def test_keyframe_track_optimize():
         track.values
         == np.array([[0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 1, 1], [0, 0, 0], [0, 0, 0]])
     )
+
+if __name__ == "__main__":
+    times = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])
+    values = np.array([0,0,0,0,1,1,1,0,0,0,0,0,0,0])
+
+    track = KeyframeTrack("test", None, None, times, values, lambda *_: None)
+
+    print("Original times:", track.times)
+    print("Original values:", track.values)
+
+    test_keyframe_track_optimize()
\ No newline at end of file
